
// Copyright 2015  Malcolm Inglis <http://minglis.id.au>
//
// This file is part of Libmaybe.
//
// Libmaybe is free software: you can redistribute it and/or modify it under
// the terms of the GNU Affero General Public License as published by the
// Free Software Foundation, either version 3 of the License, or (at your
// option) any later version.
//
// Libmaybe is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for
// more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with Libmaybe. If not, see <https://gnu.org/licenses/>.


// This file is the result of rendering:
//
//     {{template_path}}
//
// You should make changes to this file by tuning the build process, or (at a
// stretch) modifying the generation script or template file; not by editing
// this file as-is.


#include "maybe-{{filename}}.h"

#include <libmacro/assert.h>
{% for p in sys_headers %}
#include <{{p}}>
{% endfor %}

{% for p in rel_headers %}
#include "{{p}}"
{% endfor %}


Maybe_{{typename}}
maybe_{{funcname}}__id(
        Maybe_{{typename}} const m )
{
    return m;
}


Maybe_{{typename}}
maybe_{{funcname}}__nothing( void )
{
    return ( Maybe_{{typename}} ){ .nothing = true };
}


Maybe_{{typename}}
maybe_{{funcname}}__nothing_v(
        {{type}} const x )
{
    return ( Maybe_{{typename}} ){ .nothing = true };
}


Maybe_{{typename}}
maybe_{{funcname}}__value(
        {{type}} const x )
{
    return ( Maybe_{{typename}} ){ .value = x };
}


Maybe_{{typename}}
maybe_{{funcname}}__from_ptr(
        {{type}} const * const x )
{
    return ( x == NULL ) ? ( Maybe_{{typename}} ){ .nothing = true }
                         : ( Maybe_{{typename}} ){ .value = *x };
}


{{type}} const *
maybe_{{funcname}}__to_ptr(
        Maybe_{{typename}} const * const m )
{
    ASSERT( m != NULL );

    return m->nothing ? NULL : &m->value;
}


{{type}} *
maybe_{{funcname}}__to_ptrm(
        Maybe_{{typename}} * const m )
{
    ASSERT( m != NULL );

    return m->nothing ? NULL : &m->value;
}


bool
maybe_{{funcname}}__is_nothing(
        Maybe_{{typename}} const m )
{
    return m.nothing;
}


bool
maybe_{{funcname}}__is_value(
        Maybe_{{typename}} const m )
{
    return !m.nothing;
}


{{type}}
maybe_{{funcname}}__value_or(
        Maybe_{{typename}} const m,
        {{type}} const or )
{
    return m.nothing ? or : m.value;
}


Maybe_{{typename}}
maybe_{{funcname}}__applied(
        Maybe_{{typename}} const m,
        {{type}} ( * const f )( {{type}} ) )
{
    ASSERT( f != NULL );

    return m.nothing
               ? ( Maybe_{{typename}} ){ .nothing = true }
               : ( Maybe_{{typename}} ){ .value = f( m.value ) };
}


void
maybe_{{funcname}}__apply(
        Maybe_{{typename}} * const m,
        {{type}} ( * const f )( {{type}} ) )
{
    ASSERT( m != NULL, f != NULL );

    *m = maybe_{{funcname}}__applied( *m, f );
}


Maybe_{{typename}}
maybe_{{funcname}}__applied2(
        Maybe_{{typename}} const x,
        Maybe_{{typename}} const y,
        {{type}} ( * const f )( {{type}}, {{type}} ) )
{
    ASSERT( f != NULL );

    return ( x.nothing || y.nothing )
               ? ( Maybe_{{typename}} ){ .nothing = true }
               : ( Maybe_{{typename}} ){ .value = f( x.value, y.value ) };
}


void
maybe_{{funcname}}__apply2(
        Maybe_{{typename}} * const x,
        Maybe_{{typename}} const y,
        {{type}} ( * const f )( {{type}}, {{type}} ) )
{
    ASSERT( x != NULL, f != NULL );

    *x = maybe_{{funcname}}__applied2( *x, y, f );
}


bool
maybe_{{funcname}}__equal_by(
        Maybe_{{typename}} const x,
        Maybe_{{typename}} const y,
        bool ( * const eq )( {{type}} xv, {{type}} yv ) )
{
    ASSERT( eq != NULL );

    return ( x.nothing != y.nothing ) ? false
         : ( x.nothing && y.nothing ) ? true
                                      : eq( x.value, y.value );
}


ord
maybe_{{funcname}}__compare_by(
        Maybe_{{typename}} const x,
        Maybe_{{typename}} const y,
        ord ( * const cmp )( {{type}} xv, {{type}} yv ) )
{
    ASSERT( cmp != NULL );

    return ( !x.nothing && !y.nothing ) ? cmp( x.value, y.value )
                                        : y.nothing - x.nothing;
}


{% macro typeclass(name) -%}
{% if typeclasses and name in typeclasses %}
///////////////////////////////////
/// TYPECLASS: {{name}}
///////////////////////////////////
{{ caller() }}
{% endif %}
{%- endmacro %}


{% call typeclass('EQ') %}

bool
maybe_{{funcname}}__equal(
        Maybe_{{typename}} const x,
        Maybe_{{typename}} const y )
{
    return maybe_{{funcname}}__equal_by( x, y, {{funcname}}__equal );
}


bool
maybe_{{funcname}}__not_equal(
        Maybe_{{typename}} const x,
        Maybe_{{typename}} const y )
{
    return !maybe_{{funcname}}__equal( x, y );
}

{% endcall %}


{% call typeclass('ORD') %}

ord
maybe_{{funcname}}__compare(
        Maybe_{{typename}} const x,
        Maybe_{{typename}} const y )
{
    return maybe_{{funcname}}__compare_by( x, y, {{funcname}}__compare );
}


bool
maybe_{{funcname}}__less_than(
        Maybe_{{typename}} const x,
        Maybe_{{typename}} const y )
{
    return maybe_{{funcname}}__compare( x, y ) == LT;
}


bool
maybe_{{funcname}}__less_than_or_eq(
        Maybe_{{typename}} const x,
        Maybe_{{typename}} const y )
{
    return maybe_{{funcname}}__compare( x, y ) <= EQ;
}


bool
maybe_{{funcname}}__greater_than_or_eq(
        Maybe_{{typename}} const x,
        Maybe_{{typename}} const y )
{
    return maybe_{{funcname}}__compare( x, y ) >= EQ;
}


bool
maybe_{{funcname}}__greater_than(
        Maybe_{{typename}} const x,
        Maybe_{{typename}} const y )
{
    return maybe_{{funcname}}__compare( x, y ) == GT;
}


Maybe_{{typename}}
maybe_{{funcname}}__min2(
        Maybe_{{typename}} const x,
        Maybe_{{typename}} const y )
{
    return maybe_{{funcname}}__less_than( x, y ) ? x : y;
}


Maybe_{{typename}}
maybe_{{funcname}}__max2(
        Maybe_{{typename}} const x,
        Maybe_{{typename}} const y )
{
    return maybe_{{funcname}}__greater_than( x, y ) ? x : y;
}


Maybe_{{typename}}
maybe_{{funcname}}__min_n(
        Maybe_{{typename}} const * const xs,
        size_t const n )
{
    ASSERT( xs != NULL, n > 0 );

    Maybe_{{typename}} min = xs[ 0 ];
    for ( size_t i = 0; i < n; i++ ) {
        min = maybe_{{funcname}}__min2( min, xs[ i ] );
    }
    return min;
}


Maybe_{{typename}}
maybe_{{funcname}}__max_n(
        Maybe_{{typename}} const * const xs,
        size_t const n )
{
    ASSERT( xs != NULL, n > 0 );

    Maybe_{{typename}} max = xs[ 0 ];
    for ( size_t i = 0; i < n; i++ ) {
        max = maybe_{{funcname}}__max2( max, xs[ i ] );
    }
    return max;
}


Maybe_{{typename}}
maybe_{{funcname}}__clamp(
        Maybe_{{typename}} const x,
        Maybe_{{typename}} const lower,
        Maybe_{{typename}} const upper )
{
    return maybe_{{funcname}}__less_than_or_eq( x, lower )    ? lower
         : maybe_{{funcname}}__greater_than_or_eq( x, upper ) ? upper
                                                              : x;
}


bool
maybe_{{funcname}}__in_range(
        Maybe_{{typename}} const lower,
        Maybe_{{typename}} const upper,
        Maybe_{{typename}} const x )
{
    return maybe_{{funcname}}__less_than_or_eq( lower, x )
        && maybe_{{funcname}}__greater_than_or_eq( x, upper );
}


bool
maybe_{{funcname}}__in_xrange(
        Maybe_{{typename}} const lower,
        Maybe_{{typename}} const upper,
        Maybe_{{typename}} const x )
{
    return maybe_{{funcname}}__less_than( lower, x )
        && maybe_{{funcname}}__greater_than( x, upper );
}

{% endcall %}

