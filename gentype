#!/bin/env python

# Copyright 2015  Malcolm Inglis <http://minglis.id.au>
#
# This file is part of Libmaybe.
#
# Libmaybe is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# Libmaybe is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for
# more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Libmaybe. If not, see <https://gnu.org/licenses/>.


import os
from argparse import ArgumentParser
from subprocess import check_call

import jinja2


SCRIPT_PATH = os.path.realpath(__file__)
SCRIPT_DIR  = os.path.dirname(SCRIPT_PATH)

DEFAULT_DEF_TEMPLATE    = os.path.join(SCRIPT_DIR, 'def.h.jinja')
DEFAULT_HEADER_TEMPLATE = os.path.join(SCRIPT_DIR, 'header.h.jinja')
DEFAULT_SOURCE_TEMPLATE = os.path.join(SCRIPT_DIR, 'source.c.jinja')


class TemplateLoader(jinja2.BaseLoader):
    def get_source(self, environment, template_path):
        filename = os.path.join(os.getcwd(), template_path)
        mtime = os.path.getmtime(filename)
        def uptodate():
            return os.path.getmtime(filename) == mtime
        contents = read_file(template_path)
        return contents, filename, uptodate


def read_file(p):
    with open(p, 'r') as f:
        return f.read().decode()


def make_arg_parser(program_name):
    p = ArgumentParser(prog=program_name, description=
            'Renders Libmaybe\'s source and header files for the given type '
            'into the given directory. Use this script in your project\'s '
            'build process to generate files for the types you need.')
    p.add_argument('type', type=str, help=
            'The actual type in C code; e.g. `uint8_t` or `void const *`')
    p.add_argument('--typename', type=str, help=
            'The name used as the suffix of "generic" types; e.g. '
            '`Maybe_{{typename}}`. By default, this is derived from the '
            '`type` argument; e.g. `Foo const *` becomes `ptr_Foo`.')
    p.add_argument('--funcname', type=str, help=
            'The name used in the prefix of functions; e.g. '
            '`maybe_{{funcname}}__is_value()`. By default, this is the '
            '`--typename` value converted to lowercase.')
    p.add_argument('--macroname', type=str, help=
            'The name used in macros and the include guards; e.g. '
            '`LIBMAYBE_MAYBE_{{macroname}}_H`. By default, this is the '
            '`--typename` value converted to uppercase.')
    p.add_argument('--filename', type=str, help=
            'The name used in formatting the path names. By default, this is '
            'the `--typename` option converted to lowercase and underscores '
            'replaced by hyphens.')
    p.add_argument('--typeclasses', type=str, nargs='*', metavar='TC', help=
            'Typeclasses implemented by this type, if any; e.g. EQ, ORD.')
    p.add_argument('--type-func-header', type=str, help=
            '<>-include-path to the header file that declares the '
            'functions providing the given typeclasses, e.g. '
            '`{{funcname}}__equal()` or `{{funcname}}__compare()`.')
    p.add_argument('--type-def-header', type=str, help=
            '<>-include-path to the header file that declares the value type, '
            'if not provided by the language.')
    p.add_argument('--value-member', type=str, help=
            'Overrides the `value` member definition; useful if you want the '
            'value type to be an array, or a function pointer; e.g. '
            '`int value[ 8 ]` or `bool ( * value )( int )`. If you give this '
            'option, pass the empty string as `type`, and set each of the '
            'name options manually.')
    p.add_argument('--def-template', type=str,
                   default=DEFAULT_DEF_TEMPLATE, help=
            'Path to the template that defines the `Maybe_` type, if you '
            'don\'t want to use the one provided by Libmaybe.')
    p.add_argument('--header-template', type=str,
                   default=DEFAULT_HEADER_TEMPLATE, help=
            'Path to the template that defines the `maybe_` function '
            'prototypes, if you don\'t want to use the one provided by '
            'Libmaybe.')
    p.add_argument('--source-template', type=str,
                   default=DEFAULT_SOURCE_TEMPLATE, help=
            'Path to the template that implements the `maybe_` functions, if '
            'you don\'t want to use the one provided by Libmaybe.')
    p.add_argument('--output-dir', type=str, default='.', help=
            'The path to the directory to generate the files into.')
    p.add_argument('--def-path', type=str,
                   default=os.path.join('def', '{filename}.h'), help=
            'Relative path (formatted with `filename`) within the output '
            'directory to write the definition header to. All parent '
            'directories in the path will be created if needed.')
    p.add_argument('--header-path', type=str, default='{filename}.h', help=
            'Relative path (formatted with `filename`) within the output '
            'directory to write the functions header to. All parent '
            'directories in the path will be created if needed.')
    p.add_argument('--source-path', type=str, default='{filename}.c', help=
            'Relative path (formatted with `filename`) within the output '
            'directory to write the source file to. All parent directories '
            'in the path will be created if needed.')
    return p


def derive_typename(type):
    # given:    type = 'Foo    const   *  *'
    us = '_'.join(reversed(type.split()))
    # then:     us = '*_*_const_Foo'
    tn = us.replace('*_const_void', 'ptr')\
           .replace('*_void',       'ptrm')\
           .replace('*_const',      'ptr')\
           .replace('*',            'ptrm')
    # then:     tn = 'ptrm_ptr_Foo'
    return tn


def parse_args(argv):
    p = make_arg_parser(argv[0])
    args = p.parse_args(argv[1:])
    if not args.typename:
        args.typename = derive_typename(args.type)
    if not args.funcname:
        args.funcname = args.typename.lower()
    if not args.macroname:
        args.macroname = args.typename.upper()
    if not args.filename:
        args.filename = args.typename.lower().replace('_', '-')
    if not args.typeclasses:
        args.typeclasses = []
    args.def_path    = args.def_path.format(filename=args.filename)
    args.header_path = args.header_path.format(filename=args.filename)
    args.source_path = args.source_path.format(filename=args.filename)
    return args


def args_to_attrs(args):
    return {a: getattr(args, a) for a in
            ['type', 'typename', 'funcname', 'macroname', 'filename',
             'typeclasses', 'type_func_header', 'type_def_header',
             'value_member', 'def_path', 'header_path', 'source_path']}


def main(argv):
    # Parse the arguments:
    args = parse_args(argv)
    # Get the full paths of the output files:
    full_path = lambda p: os.path.join(args.output_dir, p)
    full_def_path    = full_path(args.def_path)
    full_header_path = full_path(args.header_path)
    full_source_path = full_path(args.source_path)
    # Create the path's parent directories if they don't exist:
    check_call(['mkdir', '-p', os.path.dirname(full_def_path)])
    check_call(['mkdir', '-p', os.path.dirname(full_header_path)])
    check_call(['mkdir', '-p', os.path.dirname(full_source_path)])
    # Extract the attributes from the arguments:
    attrs = args_to_attrs(args)
    # Render the templates with the attributes into the paths:
    env = jinja2.Environment(loader=TemplateLoader(),
                             undefined=jinja2.StrictUndefined)
    render = (lambda t, p: env.get_template(t)\
                              .stream(template_path=t, **attrs)\
                              .dump(p))
    render(args.def_template,    full_def_path)
    render(args.header_template, full_header_path)
    render(args.source_template, full_source_path)
    return 0


if __name__ == '__main__':
    import sys
    sys.exit(main(sys.argv))


